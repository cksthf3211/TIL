# TCP (Transmission Control Protocol)
- **전송 제어 프로토콜**
- 
## TCP 란?
- 인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나로 IP와 함께 TCP/IP라는 명칭으로도 널리 불림
- **OSI 7Layer** 중 4계층인 **전송계층**에 속하는 중요 프로토콜로 네트워크 망에 연결된 컴퓨터의 프로그램 간 데이터를 순서대로, 에러없이 교환할 수 있게 하는 역할
- 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 사용

##  프로토콜의 작동
- TCP 프로토콜의 작동은 크게 세 가지 흐름으로 구분한다.
    1. 연결 생성 (Connection establishment)
    2. 자료 전송 (Data transfer)
    3. 연결 종료 (Connection termination)
    - 신뢰성 있는 연결이 생성되어야 하며, 그 후 자료를 전송하고, 마지막으로 연결을 종료하면서 할당된 자원을 반납한다.

##  특징
### 연결 지향 프로토콜(Connection Oriented Protocol)
- 물리적으로 전용회선이 연결되어 있는 것처럼 가상의 연결통로를 설정하여 통신하는 방식으로 가상의 연결통로를 **가상회선**이라 한다.
    - **가상회선방식**  : 물리적으로 전용회선이 연결되어 있는 것처럼 논리적으로 동작하는 방식
- 논리적인 연결통로를 통해 데이터를 주고받음으로써 데이터의 전송순서를 보장해준다.
    - 순서제어 라고도 한다.
- 스트림 기반의 전송방식을 사용한다. 데이터를 임의의 크기로 나누어 연속해서 전송하는 방식을 사용한다.

### 신뢰할 수 있는 프로토콜(Reliable Protocol)
- **흐름제어**
    - 상대방이 받을 수 있을 만큼만 데이터를 효율적으로 전송하는 것
    - 흐름제어를 위해 슬라이딩 윈도우(Sliding Window) 방식을 사용
        - 이는 상대방이 수신 가능한 크기(Window size) 내에서 데이터를 연속해서 전송하는 방식으로 매 세그먼트(Segment) 전송 시마다 수신확인응답(ACK)을 수신한 후 전송하게 되면 왕복시간(RTT : Round Trip Time)이 길 경우 단위 시간당 데이터 전송량이 매우 떨어지므로 효율적으로 전송하기 위해 상대방이 받을 수 있는 범위 내에서 연속적으로 전송한다.
- **오류제어**
    - 데이터의 오류나 누락없이 안전한 전송을 보장
    - 오류 또는 누락 발생 시 재전송을 수행하여 이를 보정

- **혼잡제어**
    - 네트워크의 혼잡 정도에 따라 송신자가 데이터 전송량을 제어하는 것
    - 혼잡정도에 대한 판단기준은 데이터의 손실 발생 유무로 판단한다. 전송한 데이터에 누락이 발생하면 네트워크가 혼잡한 상태로 판단하여 전송량을 조절한다.

### TCP 연결 구조
![Alt text](../assets/TCP%20%EC%97%B0%EA%B2%B0%20%EA%B5%AC%EC%A1%B0.png)
- **Source Port(16 bits)** : 출발지(송신) 포트 번호
- **Destination Port(16 bits)** : 목적지(수신) 포트 번호
- **Sequence Number(32 bits)** : 송신 데이터 순서 번호
    - 송신 시 전송하는 데이터의 시작 바이트 순번을 담는다.
    - 바이트 순번은 전송하는 데이터의 바이트 단위로 부여하는 연속된 번호를 의미
    - 연결설정 단계에서 초기 순서 번호를 상호간에 주고받는다
    - 초기 순서 번호는 0부터 시작하는 것이 아니라 임의의 수를 할당해서 사용
- **Acknowledgment Number(32 bits)** : 상대방이 다음에 전송할 순서 번호
    - 수신 확인 응답(ACK)과 함께 해당 필드에 상대방이 다음에 전송할 순서 번호를 담아서 보낸다.
- **HLEN(4 bits)** : 헤더 길이
    - 4 bits 워드 단위로 표시(20 ~ 60 bytes)하며 기본 헤더 20 bytes와 옵션 헤더 최대 40 bytes로 구성된다.
- **Reserved(4 bits)** : 예약
- **Control Flags(6 bits)**
    - URG(Urgent pointer is valid) : 긴급 데이터 설정
    - ACK(Acknowledgment is valid) : 수신 확인 응답(ACK) 설정
    - PSH(Request for push) : 송수신 버퍼에 있는 데이터를 즉시 처리
    - RST(Reset the connection) : 연결 중단(강제 종료)
    - SYN(Synchronize sequence numbers) : 연결 설정
    - FIN(Terminate the connection) : 연결 종료 (정상 종료)
- **Window size(16 bits)**
    - 수신측에서 송신측에 보내는 Receiver window size로 수신버퍼의 여유공간 크기를 의미
    - 송신측에서는 상대방의 여유 공간 크기를 통해서 흐름제어를 수행
    - 따라서 송신측에서는 상대방의 윈도우 사이즈 범위 내에서 수신측의 수신 확인 응답(ACK)을 기다리지 않고 연속적으로 전송할 수 있는데 이를 **슬라이딩 윈도우 제어방식**이라 한다.
- **Checksum(16 bits)** : 헤더를 포함한 전체 세그먼트에 대한 오류를 검사하기 위한 필드
- **Urgent Pointer(16 bits)** : 세그먼트가 긴급 데이터(URG 플래그 설정)를 포함하고 있는 경우에 사용되는 필드로 긴급 데이터의 위치값을 담고 있다.

## 연결 생성(3-Way Handshake)
연결을 생성하기 위해, 3방향 핸드셰이크를 사용한다.

**SYN**: 클라이언트가 서버에게 SYN 메시지를 보낸다. 이 메시지에 포함된 시퀀스 번호는 클라이언트가 임의로 설정한 값 A.

**SYN-ACK**: 서버가 클라이언트에게 SYN-ACK 메시지로 응답한다. 이 메시지에 포함된 시퀀스 번호는 서버가 임의로 설정한 값 B, 응답 번호는 (A + 1).

**ACK**: 클라이언트가 서버에게 ACK 메시지를 보낸다. 이 메시지에 포함된 응답 번호는 (B + 1).

![Alt text](../assets/TCP%20%EC%84%A4%EC%A0%95%20%EA%B3%BC%EC%A0%95.png)
1. 첫번째 단계
    - 최초 클라이언트는 서버와 연결 설정을 위한 연결 요청 패킷(SYN 패킷)을 보낸다. 연결요청을 위해 능동적으로 포트를 열고 있는 상태를 "Active Open", 연결요청을 수용하기 위해 수동적으로 포트를 열고 있는 상태를 "Passive Open"이라 한다.
    - SYN은 상호간에 순서 번호를 동기화하자는 의미이며 상호간의 초기 순서 번호는 0부터가 아닌 랜덤한 값으로 시작한다.
    - 최초 SYN패킷을 보낸 TCP(소켓) 상태를 "SYN_SENT" 상태라 한다.

2. 두번째 단계
    - 클라이언트의 연결 요청(SYN 패킷)에 대한 수신 확인 응답(ACK)과 함께 서버에서 클라이언트로 연결 요청(SYN 패킷)을 보내 상호간에 연결 요청을 수행한다.
    - 수신 확인 응답을 하게 되면 반드시 Acknowledgment Number를 설정 하는데 그 의미는 상대방이 다음에 보낼 패킷의 순서 번호를 의미한다.
    - 상대방의 SYN 패킷을 수신한 TCP 상태를 "SYN_RECEIVED" 상태라고 한다.

3. 세번째 단계
    - server의 연결 요청(SYN 패킷)에 대해 수신 확인 응답(ACK)을 전송한 후 최종적으로 연결 설정이 완료된다.
    - 연결 설정이 완료되면 TCP 상태는 "ESTABLISHED" 상태가 된다

## 연결 종료(4-way handshake)
- 연결을 종료하기 위해, 4방향 핸드셰이크를 사용한다
- close() 시스템콜 함수로 종료
- TCP 연결을 종료 시 , 연결과 순서와 마찬가지로 데이터의 안정성을 위하여 서버와 클라이언트간 FIN[Finish] 를 통하여 안정적으로 종료하는 과정을 수행
- close 명령을 받은 클라이언트 TCP는 FIN 플래그가 1로 설정된 **FIN** 세그먼트를 전송한다. sequence 번호 하나를 사용
- FIN 세그먼트를 받은 서버 TCP는 서버 프로세스에 연결 종료 상황을 알린다. 이후 FIN과 ACK 플래그가 1로 설정된 **FIN+ACK** 세그먼트를 전송한다. 1번과 마찬가지로 FIN 세그먼트에 sequence 번호를 하나 사용
- 클라이언트는 서버로부터 받은 FIN 세그먼트를 확인하는 **ACK** 세그먼트를 전송한다. acknowledge 번호에 서버로부터 받은 FIN 세그먼트의 sequence 번호 + 1를 적어 보내고, 어떤 sequence 번호도 사용하지 않는다

- + FIN 세그먼트가 전송되는 경우
    1. close() 함수
    2. 프로그램 종료 시
    3. 프로그램 강제 종료 시 (^C)