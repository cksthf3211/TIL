# 자료구조 & 알고리즘

## 해쉬 테이블

- key: value로 저장하는 데이터 구조
- 키를 통해 바로 데이터를 받아올 수 있어 속도가 획기적으로 빨라짐
- 해쉬 : 임의 값을 고정 길이로 변환하는것
- 해쉬 테이블 : 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
- 해쉬 함수 : 키에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수
- 해쉬 값 / 해쉬 주소 : 키를 해싱 함수로 연산해서 해쉬 값을 알아내고 이를 기반으로 해뷔 테이블에서 해당 키에 대한 데이터 위치를 일관성있게 찾을 수 잇음
- 슬롯 : 한 개의 데이터를 저장할 수 있는 공간
- 저장할 데이터에 대해 키를 추출할 수 있는 별도 함수도 존재할 수 있음

## 힙

- 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리
- 완전 이진 트리 : 노드를 삽임할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리  
    = 최대값과 최소값을 찾으려면 O(log n)이 걸림 &lt;=&gt; 배열의 경우 O(n)  
    항상 루트노드를 가지고 오기때문에 다른 값을 찾아볼 필요가 없음   = 우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야하는 경우 많이 사용
- 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같다.

### 힙과 이진 탐색 트리의 차이

공통점 : 힙과 이진 탐색 트리는 모두 이진 트리

차이점

- 이진 탐색 트리 : 왼쪽자식노드부터 하나씩 채워나간다. (왼쪽 자식 노드의 값이 가장 작고, 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼)
- 힙 : 각 노드의 값이 자식 노드보다 크거나 같음  
    \- 힙 : 왼쪽 자식 노드 or 오른쪽 자식 노드 어느 쪽이 더 큰지 모름
- 이진 탐색 트리 : 탐색을 위한 구조
- 힙 : 최대/최소값 검색을 위한 구조

## 버블 정렬

- 인접한 데이터를 비교해서 앞에 있는 데이터보다 작은경우 바꾸어줌
- 반복문이 두개인경우 O(n^2), 최악의 경우 n*(n-1)/2
- 완전 정렬이 되어있는 경우 최선은 O(n)
- 데이터의 길이 : n (n만큼 반복을 2번함)

## 삽입 정렬
- 두번째 인덱스부터 시작
- 해당 인덱스 앞에 있는 데이터부터 비교해서 key값이 더 작으면 B값을 뒤 인덱스로 복사
- 이를 키 값이 더 큰 데이터를 만날때까지 반복, 그리고 큰 데이터를 만난 위치 바로 뒤에 key값을 이동
- 반복문이 두 개 O(n^2)
- 최악인 경우 n*(n-1)/2
- 완전 정렬인 경우 O(n)

## 선택 정렬
- 주어진 데이터 중 최소값을 찾음
- 해당 최소값을 데이터 맨 앞에 위치한 값과 교체
- 맨 앞의 위치를 뺀 나머지 데이터를 동일한 방법으로 반복
- 반복문이 두 개 O(n^2)
- 최악인 경우 n*(n-1)/2

# 절차지향 프로그래밍 VS 객체지향 프로그래밍

## 절차지향 프로그래밍
- 물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법이다.
- 가장 대표적인 언어로 C언어가 있다.
- 컴퓨터의 처리구조와 유사해 실행속도가 빠르다.
- 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

## 객체지향 프로그래밍
- 실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법
- 가장 대표적인 언어로 Java가 있다.
- 캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다. 다형성은 동일한 키보드의 키가 다른 역할을 하는 것처럼 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것을 의미한다.
- 코드를 재사용하기 쉽다.
- 절치지향 언어보다 실행속도가 느리다.
- 신뢰성 있는 소프트웨어를 쉽게 작성할 수 있다.