# 큐레이팅

## 스택
- 먼저 들어 온 데이터가 나중에 나가는 형식(선입후출)
- 입구와 출구가 동일한 형태
```python
stack.append()
stack.pop()
print(stack[::-1]) # 최상단 원소부터 출력
print(stack) # 최하단 원소부터 출력
```

## 큐
- 먼저 들어 온 데이터가 먼저 나가는 형식(선입선출)
- 입구와 출구가 모두  뚫려있는 터널과 같은 형태
```python
queue.append()
queue.popleft()
print(queue) # 먼저 들어 온 순서대로 출력
queue.reverse() # 역순으로 바꾸기
print(queue) # 나중에 들어온 원소부터 출력
```

### 우선순위 큐
- 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조
- 우선순위에 따라 처리하고 싶을 때 사용
    - 가치가 높은 물건부터 꺼내서 확인할 때
- 리스트를 이용하여 구현
- 힙(Heap)을 이용하여 구현
| 우선순위 큐 구현방식 | 삽입시간  | 삭제시간  |
|  리스트                       | O(1)          | O(N)        |
|  힙                              | O(log N)   | O(log N)  |
- 힙의 특징
    - 완전 이진 트리 자료구조
    - 항상 루트 노드를 제거
    - 최소 힙
        - 루트 노드가 가장 작은 값을 가짐
        - 따라서 값이 작은 데이터가 우선적으로 제거
    - 최대 힙
        - 루트 노드가 가장 큰 값을 가짐
        - 따라서 값이 큰 데이터가 우선적으로 제거
- 완전 이진 트리
    - 루트부터 시작하여 왼쪽 자식 노드, 오른쪽 자식 노드 순으로 데이터가 차례대로 삽입되는 트리
- 최소 힙 구성 함수(Min-Heapify)
    - (상향식) 부모 노드로 거슬러 올라가며, 부모보다 값이 더 작을 경우에 위치를 교체 
    - 새로운 원소가 삽입되었을 때 O(log N)의 시간 복잡도로 힙 성질을 유지
    - 원소가 제거되었을 때 O(log N)의 시간 복잡도로 힙 성질을 유지
        - 이후 루트 노드에서부터 하향식으로 Heapify를 진행
## 트리(Tree)
- 트리는 가계도와 같은 계층적인 구조를 표현할 때 사용할 수 있는 자료구조
    - 루트 노드(root node): 부모가 없는 최상위 노드
    - 단말 노드(reaf node): 자식이 없는 노드
    - 크기(size): 트리에 포함된 모든 노드의 개수
    - 깊이(depth): 루트 노드부터의 거리
    - 높이(height): 깊이 중 최댓값
    - 차수(degree): 각 노드의(자식 방향) 간선 개수
- 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N - 1개

###  이진 탐색 트리(Binary Search Tree)
- 이진 탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조
- 특징: 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
    - 부모 노드보다 왼쪽 자식 노드가 작다.
    - 부모 노드보다 오른쪽 자식 노드가 크다.
### 트리의 순회
- 트리자료구조에 포함된 노트를 특정한 방법으로 한 번씩 방문하는 방법
    - 트리 정보를 시각적으로 확인 가능
- 트리 순회 방법
    - 전위 순회(pre-order traverse): 루트를 먼저 방문 (맨 위 시작해서 왼쪽부터 쭈르륵)
    - 중위 순회(in-order traverse): 왼쪽 자식을 방문한 뒤에 루트를 방문 (맨 왼쪽부터 오른쪽으로 쭈르륵 )
    - 후위 순회(post-order traverse): 오른쪽 자식을 방문한 뒤에 루트를 방문 (맨 왼쪽 아래부터 쭈르륵)

### 바이너리 인덱스 트리(Binary indexed Tree)
- 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조
- **펜윅 트리(fenwick tree)** 라고도 함
- 0이 아닌 마지막 비트를 찾는 방법
    - 특정한 숫자 K의 0이 아닌 마지막 비트를 찾기 위해서 K & -K 계산
- 트리 구조 만들기
    - -0이 아닌 마지막 비트 = 내가 저장하고 있는 값들의 개수
    - 값 변경: 0이 아닌 마지막 비트만큼 더하면서 구간 들의 값을 변경( 예시 = 3rd)
    - 누적 합(prefix sum) 구하기: 0이 아닌 마지막 비트만큼 뺴면서 구간들의 값 합 계산 (예시 = 11th )

## 정렬(sorting) 알고리즘
### 선택 정렬
- 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복
- 시간 복잡도
    - N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야함
    - 구현 방식에 따라서 오차는 있지만, 전체 연산  횟수는
        - N + (N -1) + (N - 2) + … +2
    - (N² + N - 2) / 2로 표현, O(N²)

### 삽입 정렬
- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작
    - 왼쪽꺼부터 쭈르륵
- 시간 복잡도
    - O(N²)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용.
    - 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작
        - 최선의 경우O(N)의 복잡도

### 퀵 정렬
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
- 일반적인 상황에서 가장 많이 사용
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터**(pivot)를 기준 데이터로 설정
    - 왼쪽에서부터 피벗보다 큰 데이터
    - 맨 오른쪽은 작은 다음 데이터
    - 이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(N logN)
        - 너비 x 높이 = N x logN = N logN
    - 평균 O(N logN)의 시간 복잡도
    - 최악 O(N²)의 시간 복잡도
    - 
### 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작**하는 정렬 알고리즘
     - 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 떄 사용 가능
- 데이터의 개수가 N, 데이터의(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 O(N+K)를 보장
1. 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담기는 리스트 생성
2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터 1씩 증가
3. 결과적으로 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록
4. 결과를 확인할 때는 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스 출력
- 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N+K)
- 계수 정렬은 때에 따라 심각한 비효율성 초래
    - 데이터가 0과 999,999로 단 2개만 존재하는 경우 생각
- 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용
    - 성적의 경우 100점을 맞은 학생이 여러 명 일수 있끼 떄문에 계수 정렬이 효과적

### 정렬 알고리즘 비교하기
- 대부분의 프로그래밍 언어에서 지원하는 표준 정렬 라이브러리는 최악의 경우에도 O(N logN)을 보장하도록 설계

| 정렬 알고리즘  | 평균 시간 복잡도  | 공간 복잡도  | 특징                                                                                     |
| 선택 정렬         | O(N²)                    | O(N)             | 아이디어가 매우 간단하다.                                                  | 
| 삽입 정렬         | O(N²)                    | O(N)             | 데이터가 거의 정렬되어 있을 때는 가장 빠름                      | 
| 퀵 정렬             | O(N logN)            | O(N)             | 대부분의 경우에 가장 적합, 충분히 빠름                             | 
| 계수 정렬         | O(N+K)                 | O(N+K)        | 데이터의 크기가 한정되어 있는 경우에만 사용, 매우 빠름  | 

##  DFS(Depth-First Search) ※코테 중요함
- DFS는 깊이 우선 탐색이라고도 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
- DFS는 스택 자료구조(혹은 재귀 함수)를 이용하며, 구체적인 동작 과정은
    - 탐색 시작 노드를 스택에 삽입하고 방문처리
    - 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
    - 더 이상 2번의 과정을 수행할 수 없을 때까지 반복 

## BFS(Breadth-First Search)
- BFS는 너비 우선 탐색이라고도 부르며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘
- BFS는 큐 자료구조를 이용하며, 구체적인 동작 과정은
    - 탐색 시작 노드에 큐를 삽입하고 방문처리
    - 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리
    - 더 이상 2번의 과정을 수행할 수 없을 때까지 반복

## 





```python

```